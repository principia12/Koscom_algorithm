\documentclass[titlepage]{report}

\usepackage{lipsum} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{braket}
\usepackage{array}
\usepackage{calc}
\usepackage{graphicx}

\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw]{xcolor}
\usepackage{adjustbox}
\usepackage{kotex}
\usepackage{multirow}

\usepackage{avm}

\usepackage[bottom]{footmisc}

\avmfont{\sc}
\avmoptions{sorted,active}
\avmvalfont{\rm}
\avmsortfont{\scriptsize\it}

\graphicspath{{images/}}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\usepackage{xcolor}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\newtheorem{define}{Definition}
\newtheorem{imp}{Implementation}[define]

\hypersetup{%
    pdfborder = {0 0 0}, 
    colorlinks = true, 
    urlcolor = blue,
    pageanchor = false,
}


\newcommand\fig[2]{
\begin{figure}[h]
  \centering
  \includegraphics[width = \textwidth]{#1}
  \caption{#2} 
  \label{fig:#1}
\end{figure}
}




\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

% \usepackage{titlesec} % Allows customization of titles
% \renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
% \renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
% \titleformat{\chapter}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
% \titleformat{\section}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

%\renewcommand\thesubsubsection{\Roman{subsubsection}}
%\titleformat{\subsection}[block]{\large}{\thesubsubsection.}{1em}{}

\setcounter{secnumdepth}{3}

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{ Koscom Algorithm Lecture } % Custom header text
\fancyfoot[C]{\thepage} % Custom footer text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{ 코스콤 교육 강의 교재 }} % Article title

\author{
\large
\textsc{신승우}\\[2mm]
\normalsize KAIST, School of Computing \\ % Your institution
\vspace{-5mm}
}
\date{}

%----------------------------------------------------------------------------------------

\begin{document}

%\maketitle % Insert title



\begin{titlepage}
\thispagestyle{empty} % All pages have headers and footers
\maketitle % Insert title
% \begin{abstract} 

% Robot journalism have been a big issue on natural language processing area. As an example of such approach, this paper suggests full framework on baseball domain. To be more specific, three contributions are introduced here: an architecture and implementation of end-to-end framekwork for generating baseball match reports, web-based user interface for baseball reporters, and analysis on actual user experience. 
% %Implemented architecture follows the classic structure of natural language generation frameworks suggested by Reiter\cite{nlgbook}: Content Determination, Document Planning, and Surface Realization. 

% \end{abstract}

\end{titlepage}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------



\tableofcontents
\newpage

%\thispagestyle{fancy} % All pages have headers and footers
%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------



\renewcommand{\lstlistingname}{Implementation}
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}

\lstdefinestyle{python}{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}
    
\lstdefinestyle{stdout}{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}
    
    
\lstdefinestyle{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}



\chapter{Introduction and Environment Settings} 

\section{환경 설정}

\subsection{Installing Python}  
본 수업에서의 실습은 다른 라이브러리를 필요로 하지 않으므로 파이썬 개발에 필요한 최소한의 환경만 설정해주면 충분합니다. 본 환경설정법은 장고걸스 튜토리얼\footnote{\href{https://tutorial.djangogirls.org/ko/python\_installation/}{장고걸스 튜토리얼 : 파이썬 설치}}의 해당 부분을 참고하여 작성되었습니다. 

\paragraph{Windows} 

먼저, 사용 중인 컴퓨터 윈도우 운영체제가 32비트인지 64비트인지 확인해야 합니다. 확인법은 \href{https://support.microsoft.com/ko-kr/help/13443/windows-which-operating-system}{마이크로소프트 링크} 에서 찾아보실 수 있습니다. 이제 윈도우 용 파이썬 설치파일을 \href{https://www.python.org/downloads/windows/}{파이썬 공식 다운로드 링크}에서 다운로드 할 수 있습니다. 본 교재에서는 파이썬 3 버젼을 사용할 것이므로, Latest Python 3 Release - Python x.x.x 를 찾아서 다운로드받으면 됩니다. 64 비트 버전의 Windows인 경우 Windows x86-64 executable installer를 다운로드하시고, 이외에는 Windows x86 executable installer을 다운로드하면 됩니다. 설치 프로그램을 다운로드 한 후에 실행하고 지시 사항을 따르세요. 

설치하는 동안 "Setup(설치하기)"이라고 표시된 창이 나타납니다. 다음과 같이 "Add Python 3.x to PATH(python3.x를 경로에 추가)"체크 박스를 체크하고 "Install Now(지금 설치하기)"를 클릭하세요.

\paragraph{OS X} 

\href{https://www.python.org/downloads/}{파이썬 공식 사이트}로 가서 파이썬 설치 파일을 다운 받으세요. 

\begin{compactitem}
\item Mac OS X 64-bit/32-bit installer 파일을 다운받습니다.
\item python-3.6.1-macosx10.6.pkg을 더블클릭해 설치합니다.
\end{compactitem}

\paragraph{Linux} 

이미 파이썬 3이 설치되어 있을 것입니다. 

\subsection{IDE}

IDE나 코드 에디터는 개인 취향에 따라서 아래의 옵션 중 골라서 설치하시면 됩니다. 

\begin{compactitem} 
\item PyCharm : 가장 범용적으로 쓰이는 파이썬 IDE입니다. 
\item Spyder 
\item Notepad++ 
\item Atom 
\item Sublime Text 
\item Eclipse : PyDev 플러그인 사용 
\item Visual Studio Code : 파이썬 플러그인 사용
\end{compactitem} 

\subsection{Git}

Git은 버젼 관리 도구로써, 본 수업에서 필수적으로 사용되는 것은 아니지만 사용하는 것에 익숙해지면 쓰일 곳이 많습니다. 특히, 개발자에게 자신이 작성한 코드를 관리하는 것에 이만한 툴이 없습니다. 여기서는 따로 Git의 사용법을 다루지는 않습니다. 본 단락 역시 장고걸스 튜토리얼의 해당 부분\footnote{\href{https://tutorial.djangogirls.org/ko/deploy/}{장고걸스 튜토리얼 : 배포}}을 참고하였습니다. 

\paragraph{Windows, OS X} 

git-scm를 \href{git-scm.com}{링크}에서 다운로드하면 됩니다. 

\paragraph{Linux} 

sudo apt-get install git 으로 git을 다운로드할 수 있습니다. 

\section{Introduction to Python Language}


\lstinputlisting[style=python, 
                caption={Hello World! (hello.py)}]{"./examples/hello.py"}


본 단락에서는 파이썬 언어에 대해서 간단히 짚고 넘어갑니다. 

\subsection{파이썬 데이터 타입} 

파이썬은 기본적으로 다음의 빌트인 데이터 타입을 지원\footnote{\href{https://en.wikibooks.org/wiki/Python\_Programming/Data\_Types}{참조 링크 1(위키북스)}, \href{https://docs.python.org/3/library/stdtypes.html}{참조 링크 2(공식 문서)}}\footnote{여기 리스트된 데이터형이 전부는 아니지만, 중요한 데이터형들이니 잘 알아두시길 권장합니다.}합니다. 

\begin{compactitem} 
\item Boolean Type : 참/거짓 값을 나타내는 타입입니다. 
\item Numeric Types : 일반적으로 쓰이는 숫자를 나타내는 타입입니다. 
\item Sequential Types : 배열 형태의 타입입니다. 
\item Mapping Types : key-value 순서쌍 형태의 타입입니다. \footnote{프로그래밍 지식이 있으신 분은 파이썬에서의 dict가 해쉬라고 생각하시면 좋습니다.}
\end{compactitem}

아래에서는 각 타입의 종류와 다양한 연산법에 대해서 알아볼 것입니다. 


\paragraph{Boolean Type} 참(True), 거짓(False)값을 나타냅니다. Boolean 값들은 and, or, not 연산이 가능합니다. 연산의 결과는 아래와 같습니다. 

\lstinputlisting[style=python, 
                caption={Boolean Example  (example\_bool1.py)}]{"./examples/example_bool1.py"}


\paragraph{Numeric Types} int, float, complex가 있습니다. 각각 정수, 실수\footnote{차후에 다루겠지만, 정확하게 실수를 나타내는 것은 불가능합니다. 더 정확하게는, 모든 실수를 정확하게 나타내는 것은 불가능합니다. 여기서의 float은 c언어에서의 double과 같다고 보는 것이 정확합니다.}, 그리고 복소수를 나타냅니다. 

\lstinputlisting[style=python, 
                caption={Numeric Types  (example\_numeric1.py)}]{"./examples/example_numeric1.py"}

파이썬은 일반적인 사칙연산을 지원합니다. 아래에서 어떤 식으로 사칙연산이 사용되는지 볼 수 있습니다. 

\lstinputlisting[style=python, 
                caption={Operations for Numeric Types  (example\_numeric2.py)}]{"./examples/example_numeric2.py"}


\paragraph{Sequential Types} 파이썬에서는 list, tuple, range, string 등의 배열 형태의 데이터형을 지원합니다. 여기서는 문자열 데이터형 string에 대해서 따로 다루지는 않으며, 더 자세한 정보는 \href{https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range}{공식 Documentation}을 참고하시면 됩니다. 

\lstinputlisting[style=python, 
                caption={Sequential Types  (example\_sequence1.py)}]{"./examples/example_sequence1.py"}


Sequence 데이터형들은 다음의 연산들을 지원합니다. 
\begin{compactitem} 
\item a in d : 배열(d) 안에 특정 원소(a)가 있는지를 검사합니다. 
\item + : 배열 두 개를 이어서 새로운 배열을 만듭니다. 같은 데이터형이여야 합니다. 
\item d[i] : d의 i번째 원소를 반환합니다. 
\item d[i:j:k] : d의 i번째 원소부터 j번째 원소까지, k번째 원소마다 선택하여 리스트를 만들어 반환합니다. 
\item d.index(elem) : d에서 elem 이 처음으로 나오는 위치를 반환합니다. 
\end{compactitem}
\lstinputlisting[style=python, 
                caption={Operations for Sequential Types  (example\_sequence2.py)}]{"./examples/example_sequence2.py"}


\paragraph{Mapping Types} key-value 쌍을 저장하는 데이터형으로, 파이썬에서는 dict가 있습니다. 

\lstinputlisting[style=python, 
                linerange  = {1-6, 27},
                caption={Mapping Types  (example\_dict1.py, line 7-26 omitted)}]{"./examples/example_dict1.py"}

dict는 다음의 연산을 지원합니다. 
\begin{compactitem} 
\item d[key] : dict에서 key에 해당되는 value를 반환합니다. 
\item d[key] = val : dict에서 key에 해당되는 value를 val로 업데이트합니다. 
\item d.keys() : dict의 key들을 반환합니다. 
\end{compactitem}

\lstinputlisting[style=python, 
                caption={Operations for Mapping Types  (example\_dict2.py)}]{"./examples/example_dict2.py"}


\subsection{파이썬 문법 : loops, conditionals} 

\paragraph{if-elif-else} 다른 모든 언어와 비슷하게, 파이썬에서도 if-else 문을 지원합니다. 아래와 같은 문법으로 사용됩니다. 

\begin{lstlisting}[style=python] 
if cond1:
    # when cond1 is True 
elif cond2:
    # when cond1 is False and cond2 is True
else:
    # when cond1 is False and cond2 is False
\end{lstlisting}

\paragraph{switch} 파이썬에서는 switch문을 지원하지 않습니다. 하지만, 아래와 같이 switch문을 대체하여 사용할 수는 있습니다. 

\lstinputlisting[style=python, 
                caption={Switch using dict (example\_switch1.py)}]{"./examples/example_switch1.py"}



\paragraph{for loop} 파이썬에서의 for loop는 임의의 Sequential Type 변수에 대해서, 그 변수 안의 원소를 한번씩 돌게 됩니다. 예를 들어서 아래 코드를 살펴봅시다. 

\lstinputlisting[style=python, 
                caption={For Loop Example (example\_for1.py)}]{"./examples/example_for1.py"}


\paragraph{while loop} 파이썬에서의 while문은 다른 언어에서의 while문과 크게 다르지 않습니다. 아래의 소스 코드를 살펴보면 알 수 있을 것입니다. 


\lstinputlisting[style=python, 
                caption={While Loop Example (example\_while1.py)}]{"./examples/example_while1.py"}
                
                
\subsection{파이썬 문법 : 함수, 클래스}

\subsubsection{함수}

파이썬에서 함수는 다음과 같이 정의합니다. 


\lstinputlisting[style=python, 
                caption={Function Syntax (example\_function1.py)}]{"./examples/example_function1.py"}
                
위 소스코드에서 각 항목은 아래와 같은 의미를 가집니다. 

\begin{compactitem} 
\item def : 함수 정의 키워드입니다. 
\item function : 함수 이름을 나타냅니다. 
\item args : 함수 인자입니다. 아래와 같은 옵션이 있습니다. 
\begin{compactitem} 
\item arg 
\item arg\_default : 함수 인자의 기본값을 정해줄 때, =을 이용하여 기본값을 지정해줄 수 있습니다. 
\item *arg\_list : 정해지지 않은 수의 인자를 받고자 할 때, *을 하나 붙여서 들어온 인자를 배열로 받을 수 있습니다. 
\item **arg\_dict : 정해지지 않은 수의 이름이 명시된 인자를 받고자 할 때, *를 두개 붙여서 들어온 인자들을 dict 형태로 받을 수 있습니다. 
\end{compactitem} 
\item return None : 함수의 결과값으로 return 뒤의 구문을 반환합니다. 
\end{compactitem}


아래의 코드\footnote{\href{https://stackoverflow.com/a/21338152}{stackoverflow 질문 : Understanding kwargs in Python} 참조}를 보면 조금 더 명백해집니다. 

\lstinputlisting[style=python, 
                caption={Function Argument Options (example\_function2.py)}]{"./examples/example_function2.py"}
                
위 프로그램의 실행 결과는 다음과 같습니다. 

\begin{lstlisting}[style=stdout, caption = {Output for Function Argmument Options}]
Calling f(1, 2, 3, 4, b = 5, c = 6)
Received by f(a, *args, **kwargs) 
=> f(a=1, args=(2, 3, 4), kwargs={'c': 6, 'b': 5}
Calling g(10, 11, 12, *args, d = 13, e = 14, **kwargs)
Received by g(f, g = 0, *args, **kwargs)
=> g(f=10, g=11, args=(12, 2, 3, 4), kwargs={'c': 6, 'b': 5, 'e': 14, 'd': 13})
\end{lstlisting}

\paragraph{람다 함수}

람다 함수란 익명함수를 뜻합니다. 이는 람다함수가 변수명을 가질 수 없음을 의미하는 것이 \textbf{아닙니다.} 예컨대, 아래의 코드에서의 func1, func2는 둘 다 같은 함수(주어진 수에 2를 더하는)이며, func1은 람다식으로 작성되었지만 엄연히 func1이라는 이름을 가지고 있습니다. 

\lstinputlisting[style=python,  
                caption={Lambda Function Example (example\_lambda1.py)}]{"./examples/example_lambda1.py"}

람다식의 문법은 위 소스 코드에서 볼 수 있듯이 다음과 같이 이루어집니다. 

\begin{compactitem} 
\item lambda : 람다함수 키워드. 람다함수 뒤의 구문 중 콜론 전에 있는 구문은 함수의 인자를, 뒤는 반환하는 값을 나타낸다. 
\item x,y,z(func3)/*args(func4) : 람다함수의 인자. 쉼표로 구분되며, 상기된 *args등도 똑같이 사용 가능함을 func4에서 확인할 수 있다. 
\item x+y+z(func3)/sum(args)(func4) : 람다함수의 반환값. 
\end{compactitem}

익명함수가 가지는 이점 중 하나는, 우리가 정수나 문자열을 다루듯이 함수 또한 하나의 변수로 다루고 싶을 때 편리하다는 점입니다. 본 단락에서는 일반화된 정렬 문제에서 어떤 식으로 람다식이 사용가능한지 보여드리고자 합니다. 

어떤 배열을 정렬하는 문제를 생각해 봅시다. 이 때, 어떤 배열의 원소들이 정수라면 정렬 결과에는 이의가 없을 것입니다. 예컨대, 아래의 코드의 마지막 라인에서 AssertionError가 나지 않는다면 충분할 것입니다. \footnote{물론 실전에서는 더 많은 테스트를 하시는 것을 권장드립니다.}


\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort1.py)}]{"./examples/example_lambda_sort1.py"}


하지만 주어진 리스트가 비교하기 어려운 것들로 되어있는 경우 - 예를 들어서, 숫자 3개짜리 튜플로 되어있는 경우 - 에는 어떤 식으로 배열할 수 있을까요? 이를 위해서는 우선 배열의 원소를 서로 비교하기 위한 기준이 필요할 것입니다. 위 코드의 경우 원소간의 비교 기준은 대소관계이며, 8번째 라인(head>=elem)에 이것이 반영되었다고 볼 수 있습니다. 여기서는 이 기준을 세 숫자의 합으로 생각해 봅시다. 그렇다면, 새로운 기준(세 숫자의 합)을 아래와 같이 반영할 수 있을 것입니다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort2.py)}]{"./examples/example_lambda_sort2.py"}


이제 여기서 조금 더 나아가서, 다음과 같은 소스를 생각해 봅시다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort3.py)}]{"./examples/example_lambda_sort3.py"}

여기서, 위 소스를 조금 더 간소화해서 애초에 compare 함수를 def를 쓰지 않고 람다식을 이용하여 저렇게 쓸 수 있습니다. 

\lstinputlisting[style=python,  
                caption={Inspecting Function Calls  (example\_lambda\_sort4.py)}]{"./examples/example_lambda_sort4.py"}

\subsubsection{클래스}

본 단락에서는 파이썬에서 클래스를 어떻게 정의하는지를 살펴보고자 합니다. 

\paragraph{클래스란} 

클래스는 흔히 과자틀과 그 과자틀로 찍어낸 과자로 비유됩니다.  클래스는 객체를 만들기 위한 코드 템플릿\footnote{https://www.hackerearth.com/practice/python/object-oriented-programming/classes-and-objects-i/tutorial/}을 말합니다. 인스턴스는 이 템플릿을 이용하여 만들어진 코드 덩어리로 생각할 수 있습니다. 예\footnote{본 예시는 \ href{https://wikidocs.net/28}{점프 투 파이썬}에서 참고하였습니다.}를 들어서, 더하기만 가능한 간단한 계산기 코드를 만든다고 가정합시다. 다음과 같이 전역변수를 사용하면 어렵지 않게 구현할 수 있을 것입니다. 

\lstinputlisting[style=python,  
                caption={더하기만 가능한 계산기  (example\_cal1.py)}]{"./examples/example_cal1.py"}

이 때, 각자 다른 계산기를 2개를 만들어서 사용하고자 하면, 다음과 같이 2개의 계산기를 만들어야 할 것입니다.

\lstinputlisting[style=python,  
                caption={더하기만 가능한 계산기 2개 (example\_cal2.py)}]{"./examples/example_cal2.py"}

이렇게 코드를 작성할 경우, 완벽하게 똑같은 코드를 두 번 작성해야 함을 알 수 있습니다. 따라서 이러한 중복을 피하기 위해서, 파이썬에서는 - 그리고 객체지향적 언어에서는 - 클래스를 제공합니다. 클래스는 다음과 같이 계산기 코드를 템플릿화하여, 재사용이 용이하게 만듭니다. 


\lstinputlisting[style=python,  
                caption={더하기 계산기 클래스  (example\_cal3.py)}]{"./examples/example_cal3.py"}

이 때, cal1, cal2는 클래스 Calculator의 인스턴스입니다. 

클래스를 사용하는 이유는 개발의 속도와 유지보수의 편의성, 그리고 코드 디자인의 간결성 때문입니다. 잘 구성된 클래스의 경우, 구현하고자 하는 대상과 구현하는 프로그램 소스 코드간 대응이 직관적입니다. 예컨대 회계사용 프로그램을 작성할 경우, 고객/법인/재무재표 등의 클래스를 사용하게 될 것입니다. 이런 경우, 단순 코드 블럭으로 되어있는 것보다 더 직관적으로 프로그램 전체의 구조를 이해할 수 있으며, 이는 개발 속도와 정확도에 긍정적인 영향을 끼칠 것입니다. 프로그램의 유지보수 측면에서도 이와 비슷한 이유로 추후 유지보수가 간결해집니다. 

이제 조금 더 자세하게 클래스(특히, 파이썬에서의 클래스에 대해서) 알아보겠습니다. 

\paragraph{파이썬에서의 클래스} 

위 단락에서 클래스가 무엇인지, 그리고 왜 필요한지에 대해서 간단하게 살펴보았습니다. 본 단락에서는 클래스를 구성하는 요소를 살펴보고, 이를 정의하는 파이썬 문법에 대해서 알아보고자 합니다. 이해를 돕기 위해서 여기서는 문자열을 다루는 간단한 클래스를 만들어보고자 합니다. 먼저, 

클래스는 속성(attribute)와 메소드(method)로 구성됩니다. 속성은 클래스 속성과 인스턴스 속성으로 분류되며, 메소드는 인스턴스 메소드, 클래스 메소드, 스태틱 메소드로 분류됩니다. \footnote{파이썬의 경우, private method를 지원하기는 하나 완벽하게 private하지는 않습니다. \_\_로 시작하는 속성이나 메소드는 private로 분류되지만, 이것이 완벽하게 클래스 밖에서 은닉되어 있지는 않습니다. 예컨대, 클래스 이름이 Mycls이고 속성이 \_\_attr1일 경우, Mycls\_\_attr1 로 접근할 수 있습니다. 더 자세한 내용은 \href{http://www.diveintopython.net/object\_oriented\_framework/private\_functions.html}{참고 링크}를 참고하세요. } 

각각의 예시에 대해서 아래 코드에서 살펴보겠습니다. 먼저, 가장 기본적인 부분만을 작성한 코드를 살펴보겠습니다. 

\lstinputlisting[style=python,  
		linerange = {1-8},
                caption={Making a MyString Class  (example\_class1.py)}]{"./examples/example_class1.py"}

위 코드에서 파이썬 클래스의 각 요소들을 설명하면 다음과 같습니다. 
\begin{compactitem} 
\item class : 클래스를 정의하는 키워드입니다. 이 키워드 뒤의 단어가 클래스의 이름이 됩니다. 여기서는 MyString입니다. 
\item maker = 'Schin' : 클래스의 \textbf{속성}을 지정합니다. 여기서는 class\_name, maker, datum의 3개의 속성이 있습니다. 편의상 datum을 우리가 다루고자 하는 문자열로 생각하겠습니다. 
\item a = MyString : a라는 변수의 값으로 MyString이라는 \textbf{클래스}를 지정합니다. 
\item b = MyString() : b라는 변수의 값으로 MyString이라는 \textbf{인스턴스}를 지정합니다. 
\end{compactitem}

여기서 클래스(a)와 인스턴스(b)의 차이를 살펴보기 위해서 다음 코드를 실행해 보겠습니다. 

\lstinputlisting[style=python,  
		linerange = {10-17},
                caption={Making a MyString Class  (example\_class1.py)}]{"./examples/example_class1.py"}

여기서 볼 수 있듯이, 클래스 자체의 변화는 인스턴스에 영향을 주지만 그 역은 성립하지 않습니다. 이는 모든 인스턴스는 클래스의 틀을 따르기 때문입니다. 위에서의 쿠키틀의 예시를 들면, 쿠키 하나를 바꾼다고 쿠키틀이 바뀌지는 않는 것과 같습니다. 반대로, 쿠키틀을 바꾸면 모든 쿠키는 영향을 받게 됩니다. 


본격적으로 문자열을 다루기 위해서 b에 우리가 다루고자 하는 문자열을 저장하고자 합니다. 이는 다음과 같은 방식으로 할 수 있습니다. 

\lstinputlisting[style=python,  
		linerange = {19-20},
                caption={MyClass Attribute   (example\_class1.py)}]{"./examples/example_class1.py"}

이제 이 후에는 어떻게 해야 할까요? 문자열을 저장하는 것만으로는 충분하지 않습니다. 이제 조금 더 복잡한 클래스 문법을 살펴보겠습니다. 

\lstinputlisting[style=python,  
		linerange = {1-33},
                caption={Making a MyString Class  (example\_class2.py)}]{"./examples/example_class2.py"}

\begin{compactitem}
\item 속성(Attribute) : 클래스나 인스턴스가 가지고 있는 정보를 말합니다. 예를 들어서, 문자열의 경우라면 문자열의 내용이나 저자 등이 있을 것입니다. 
\begin{compactitem} 
\item 클래스 속성  : 클래스 자체가 가지고 있는 속성을 말합니다. 예를 들어서, 문자열의 경우라면 클래스 이름 MyString 등이 있습니다. 
\item 인스턴스 속성 : 인스턴스 각각이 가지고 있는 속성을 말합니다. 예를 들어서, 문자열의 경우라면 문자열의 내용 등이 있습니다. 
\end{compactitem}
\item 메소드(method) : 클래스나 인스턴스의 상태를 변화시키거나, 새로운 클래스를 만드는 등의 작업을 하는 함수입니다. 
\begin{compactitem} 
\item 인스턴스 메소드 : 인스턴스에 대해서 작동하는 함수입니다. 인스턴스를 변형시키거나 인스턴스를 이용하여 어떠한 작업을 수행합니다. 
\item 클래스 메소드 : 클래스에 대해서 작동하는 함수입니다. 클래스 자체를 변형시킬 수 있습니다. 
\item 스태틱 메소드 : 클래스나 인스턴스와 상관없는 함수입니다. 보통 클래스 내에서만 쓰이지만, 딱히 인스턴스나 클래스의 정보를 필요로 하지 않는 경우에 쓰입니다. 

\end{compactitem}
\end{compactitem}



위 소스 코드를 통해서 우리는 다음과 같은 일들을 할 수 있습니다. 

\lstinputlisting[style=python,  
		linerange = {42-55},
                caption={MyClass Attribute   (example\_class2.py)}]{"./examples/example_class2.py"}



\paragraph{Magic Methods} Magic Method는 대표적인 syntactic sugar로써, 일반적으로 \_\_\textit{method\_name}\_\_형태로 메소드를 지칭합니다.
%
%\lstinputlisting[style=python,  
%               caption={Inspecting Function Calls  (example\_class2.py)}]{"./examples/example_class2.py"}
%
%\paragraph{클래스 상속} 클래스 상속\footnote{\href{https://www.python-course.eu/python3\_inheritance.php}{링크} 참조}
%
%\lstinputlisting[style=python,  
%               caption={Inspecting Function Calls  (example\_class3.py)}]{"./examples/example_class3.py"}

\section{파이썬 인터프리터의 이해}

본 단락에서는 주어진 소스 코드를 파이썬이 계산하는 법을 알아볼 것\footnote{\href{https://docs.python.org/3/reference/executionmodel.html}{파이썬 공식 Documentation} 참조}입니다. 본격적인 설명에 앞서, 변수의 종류에 대해서 설명하겠습니다. 일반적으로 변수에는 다음의 세 종류가 있습니다. 

\begin{compactitem} 
\item Bound variable : 어떤 값이나 다른 변수에 의해서 값이 결정되는지 정해진 변수
\item Binding variable : Bound variable의 값을 결정하는 변수 
\item Free variable : Bound되지 않은 변수 
\end{compactitem}

이 때, 파이썬 인터프리터\footnote{사실 많은 인터프리터가 대부분 이렇게 동작합니다.}는 \textbf{bound variable을 binding variable로 대체(substitute) 하여} 계산합니다. 만약 계산해야 하는 모든 변수들의 값이 결국 어떤 값(숫자, 문자열 등등)으로 환원되면 그 값을 계산하여 반환하고, 그렇지 않다면 에러를 반환합니다. 따라서 파이썬 인터프리터의 동작을 이해하는 것은 곧 어떤 식으로 변수들이 서로를 bind/bound 하는지를 이해하고, 이를 기반으로 \textbf{기계적으로} 변수를 적절한 값으로 대체하여 계산을 수행함을 의미합니다. 

Binding이 일어나는 경우는 아래와 같습니다. 

\paragraph{import문의 사용} import문을 사용할 경우, import된 모듈에서의 모든 namespace가 bind됩니다. 

\paragraph{for loop} for loop에서 헤더는 루프 코드블럭 안에서 for loop 헤더에서 선언된 변수를 bind 합니다. 

\paragraph{함수, 클래스의 정의} 함수나 클래스의 정의는 함수나 클래스 이름을 bind하게 됩니다. 예를 들어서 아래 소스코드를 보면, compare이라는 변수는 1번 라인에 의해서 2번 라인에 binding되어, 14번 라인을 거쳐 11번 라인에서 쓰이게 됩니다. 


\lstinputlisting[style=python,  
                caption={Binding in Function definition  (example\_lambda\_sort3.py)}]{"./examples/example_lambda_sort3.py"}

\paragraph{=의 사용} 

예를 들어서, 아래의 소스코드에서는 각각 a,b가 bound variable, a가 binding variable, c가 free variable입니다. 
\lstinputlisting[style=python, 
                caption={Types of Variables (variables.py)}]{"./examples/variables.py"}

\paragraph{함수 인자의 binding} 

함수 인자 역시 함수가 정의된 곳 내에서의 binding을 야기합니다. 예를 들어서 아래 소스코드를 살펴봅시다. 

\lstinputlisting[style=python, 
                caption={Inspecting Function Calls  (example\_interpreter1.py)}]{"./examples/example_interpreter1.py"}
                
이 때 출력될 값은 321일 것입니다. 이를 이해하기 위해서 파이썬 인터프리터 안에서 어떤 일이 벌어지는지 한 단계씩 살펴보도록 하겠습니다. 

\begin{enumerate} 
\item line 12 : func1('123')을 호출, 반환된 값을 출력함
\item line 1 : func1 정의된 부분으로 감
\item line 2-7 : 이 부분의 식을 계산하되, input\_num을 '123'으로 대체하여 계산함 (=binding이 일어남: input\_num 이 '123'에 bind됨)
\begin{enumerate}
\item line 2-4 : int('123'[0]) == 1 과 같은 계산을 반복 
\item line 7 : func2(1,2,3)을 호출, 반환된 값을 반환함
\end{enumerate}
\item line 9 : func2 정의된 부분으로 감 
\item line 10 : 100c + 10b + a 계산하되, a,b,c를 각각 1,2,3으로 대체하여 계산함 (=binding이 일어남 : a,b,c가 각각 1,2,3에 bind됨)
\end{enumerate}

%--------------------------------------------------------
% Due 8/28
%-------------------------------------------------------- 

\chapter{Computation과 데이터구조의 이해}
% 계산이란? Computational Model과 그에 따른 복잡도의 이해
% 데이터구조와 ADT의 차이. 모델/인터페이스와 구현의 구분. 
% 예시 : disjoint set 
% 알고리즘의 개념적 이해
% recursion 및 dynamic programming 이해 
 

\section{데이터구조 vs Abstract Data Type} 

컴퓨터를 이용하여 어떤 계산을 할 때, 우리는 정해진 operation들을 이용하여 원하는 결과를 얻습니다. 예를 들어서, 우리가 어떤 숫자의 배열을 정렬하고 싶다면 숫자간의 비교를 하는 것이 우리가 사용할 operation이 될 것입니다. 이러한 operation들은 상황에 따라서 필요한 operation들을 정의하여 사용하게 됩니다. 이 때 정의된 operation들의 집합을 \textbf{Abstract Data Type(ADT)}이라고 합니다. 그리고 이것을 구현하기 위한 구조체를 \textbf{데이터구조}라고 합니다. ADT와 데이터구조는 헷갈리기 매우 좋은데, 이는 이름이 같은 경우가 많기 때문입니다. 예를 들어서, 트리는 문맥에 따라서 ADT일 수도, 데이터구조일 수도 있습니다. 이 둘을 구분하는 방법은 구현에 대한 언급이 있는지를 살펴보는 것입니다. 

ADT와 데이터구조의 관계는 자바에서 interface와 클래스의 관계나, C++에서 추상 클래스와 클래스의 관계와 매우 비슷합니다. 이 둘을 구분하는 것은 구현과 구조의 분리라는 객체지향의 원리를 지킨다는 측면에서 중요합니다. 또한, 다른 데이터구조를 사용할 때 같은 ADT더라도 성능이 달라질 수 있으므로 상황에 따라서 적절한 구현을 고르기 위해서는 ADT와 데이터구조를 분리하여 생각하는 것이 좋습니다. 

구체적인 예를 들기 위해서 list ADT를 정의하고, 이를 두 가지의 다른 데이터구조(array, linked list)로 구현했을 때의 차이점을 살펴보겠습니다. 

\paragraph{List ADT Specification} 

개념적으로 list는 head, tail로 정의되며, head는 임의의 데이터, tail은 리스트입니다. 이 때 tail이 아무런 element도 없는 리스트일 경우 Nil\footnote{언어에 따라 다르지만, None이라고도 하고 Null이라고도 합니다. 파이썬의 경우 None을 사용합니다.}이라고 합니다. 

List ADT는 다음과 같은 operation들을 말합니다\footnote{이는 필수적으로 있어야 하는 것들만 포함하는 것이고, 대개의 경우 이것 외에도 많은 것들을 포함시킬 수 있습니다.}. 

\begin{itemize} 
\item \_\_init\_\_ : 빈 리스트를 만드는 constructor
\item is\_empty : 리스트가 비어 있으면 True, 아니면 False를 리턴. 
\item prepend / append : 리스트의 앞/뒤에 어떤 element를 넣는 함수. 
\item head : 리스트의 첫 번째 원소를 리턴. 
\item tail : 리스트의 첫 번째 원소를 제외한 나머지 원소들을 리턴. 
\end{itemize}

이를 파이썬 코드로 나타내면 다음과 같습니다. 

\lstinputlisting[style=python,  
                caption={List ADT  (List.py)}]{"./examples/list/List.py"} 

여기서 1번째, 3번째 라인은 파이썬에서 추상 클래스를 만들기 위한 장치이며, @abstractmethod는 이 메소드가 추상 메소드임을 의미합니다. List를 상속받는 클래스는 @abstractmethod 데코레이터가 있는 메소드들을 구현하여야 합니다. 여기서는 파이썬 언어 강의가 아니므로, 그냥 자바에서의 인터페이스로 받아들이면 충분합니다. 

\paragraph{Implementation Using Array Data Structure} 

Array는 \textbf{인접한 메모리}에 데이터를 저장하는 데이터구조를 의미합니다. 데이터가 인접한 메모리에 저장되어 있으므로, 임의의 element에 접근하는 것이 상수 시간에 이루어집니다. \footnote{예를 들어서, 크기가 10인 데이터를 담고 있는 array의 시작 주소를 알고 있다면, i번째 데이터는 시작점에 10*i만큼을 더함으로써 주소값을 바로 얻을 수 있으며, 따라서 array 내 임의의 원소에 상수 시간에 접근이 가능합니다.} \footnote{파이썬에서는 C처럼 메모리를 명시적으로 다루기 어렵기 때문에, 여기서는 array를 이용한 구현은 생략합니다.} 이 때, 각 operation은 다음과 같이 구현될 수 있습니다. 

\begin{itemize} 
\item \_\_init\_\_ : 빈 리스트를 만드는 constructor

빈 배열을 반환합니다. 
\item is\_empty : 리스트가 비어 있으면 True, 아니면 False를 리턴. 
\item prepend / append : 리스트의 앞/뒤에 어떤 element를 넣는 함수. 

append의 경우, array에 빈 공간이 있고 array의 원소 갯수를 알고 있으면 넣어야 할 주소값에 element를 넣으면 되며, 만약 빈 공간이 없으면 array의 크기를 늘린 후 넣으면 됩니다. 이런 경우, amortized cost \footnote{간단하게 말하면, array의 크기를 늘리는 malloc 함수는 비싼 함수지만 이를 부를 일이 많지 않으므로, 이를 고려하여 계산하는 것.}는 상수시간으로 볼 수 있습니다. 

하지만 prepend의 경우는 array의 내용들을 memcpy를 이용하여 복사하여 element의 크기만큼 shift 해야 하므로 array에 있는 내용에 비례하는 시간이 걸리게 됩니다. 
 
\item head : 리스트의 첫 번째 원소를 리턴. 

Array의 시작부터 element의 크기만큼의 비트를 리턴해주면 됩니다. 

\item tail : 리스트의 첫 번째 원소를 제외한 나머지 원소들을 리턴. 

Array에서 head를 제외하고 나머지를 리턴해주면 됩니다. 
\end{itemize}

\paragraph{Implementation Using Linked List}

\fig{linkedlist}{Linked List의 구조} 

Linked list는 위와 같이, 데이터와 그 다음 데이터로의 주소값으로 이루어진 데이터구조입니다. 맨 처음과 끝에 Null값을 붙일 수도, 안 붙일 수도 있습니다. Linked list는 list의 개념적인 정의에 매우 충실한 구조인데, 이는 head 뒤에 다음 element로의 포인터를 tail로 보면 tail 또한 linked list이기 때문입니다. 

Linked List에서는 각 operation을 다음과 같이 구현할 수 있습니다. 

\begin{itemize} 
\item \_\_init\_\_ : 빈 리스트를 만드는 constructor
\lstinputlisting[style=python,  
                linerange = {5-7},     
                caption={LinkedList Constructor (LinkedList.py)}]{"./examples/list/LinkedList.py"} 
                
여기서는 빈 list를 head, tail 모두 None인 리스트로 생각합니다. 

\item is\_empty : 리스트가 비어 있으면 True, 아니면 False를 리턴. 
\lstinputlisting[style=python,  
                linerange = {15-16},     
                caption={LinkedList is\_empty  (LinkedList.py)}]{"./examples/list/LinkedList.py"} 
                
위 empty list의 정의에 따라, head와 tail이 None인지 체크합니다. 

\item prepend / append : 리스트의 앞/뒤에 어떤 element를 넣는 함수. 

prepend는 리스트의 앞에 element를 추가하는 것으로, 다음의 과정을 통해서 이루어집니다. 

\lstinputlisting[style=python,  
                linerange = {18-23},     
                caption={LinkedList prepend  (LinkedList.py)}]{"./examples/list/LinkedList.py"} 
                
먼저, 새 LinkedList를 만든 후, head에 item을 첨가합니다. 이후 새로 만든 LinkedList의 tail을 기존 LinkedList로 만든 후, 새로 만든 LinkedList를 반환합니다. 이 과정에서 tail은 언제나 None 아니면 LinkedList일 것입니다. 또한, 이 operation은 지금 리스트 안에 들어 있는 element의 갯수와 상관 없이 상수 시간이 걸릴 것입니다. 

이와는 달리, append는 다음의 과정을 통해서 이루어집니다. 
                
\lstinputlisting[style=python,  
                linerange = {25-34},     
                caption={LinkedList append  (LinkedList.py)}]{"./examples/list/LinkedList.py"} 
                
만약 리스트가 비어 있는 경우 prepend와 똑같이 시행합니다. 그렇지 않은 경우, 빈 LinkedList를 만들어 head에 item을 넣습니다. 그 후, 원 LinkedList의 tail에서 None을 발견할 때까지 LinkedList를 traverse한 후, tail이 None인 LinkedList를 발견하면 tail을 새로 만든 LinkedList로 대체합니다. 이 과정에서는 LinkedList를 한 번 끝까지 traverse 해야 하므로, 리스트 내의 element 갯수에 선형적으로 비례하는 시간이 걸립니다. \footnote{이를 방지하기 위해서, tail 뿐만 아니라 앞쪽 방향의 list도 미리 저장하는 doubly linked list를 사용하기도 합니다.} 

\item head : 리스트의 첫 번째 원소를 리턴. 

\lstinputlisting[style=python,  
                linerange = {36-37},     
                caption={List ADT  (LinkedList.py)}]{"./examples/list/LinkedList.py"} 

\item tail : 리스트의 첫 번째 원소를 제외한 나머지 원소들을 리턴. 

\lstinputlisting[style=python,  
                linerange = {39-40},     
                caption={List ADT  (LinkedList.py)}]{"./examples/list/LinkedList.py"} 
\end{itemize}

\paragraph{Comparison} 

각 operation의 복잡도는 다음과 같이 정리할 수 있습니다. 


\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline
             & ArrayList & LinkedList                        \\ \hline
\_\_init\_\_ & O(1)      & O(1)                              \\ \hline
is\_empty    & O(1)      & O(1)                              \\ \hline
prepend      & O(n)      & O(1)                              \\ \hline
append       & O(1)      & O(n) (O(1) if doubly linked list) \\ \hline
head/tail    & O(1)      & O(1)                              \\ \hline
\end{tabular}
\end{table}

만약 Binary Tree나 B+ 트리 같은 데이터구조를 사용한다면 복잡도는 또 달라지게 됩니다. 이에 대해서는 뒤 단원에서 더 자세하게 다뤄 보도록 하겠습니다. 

\section{Concept of Algorithm} 

위와 같이 ADT에서 operation들을 정의하였으면, 이를 레고 블럭을 조립하듯이 적절히 조합하여 원하는 계산을 행하는 것을 \textbf{알고리즘}이라고 합니다. 따라서, 알고리즘이 적절히 정의되기 위해서는 사용할 ADT를 먼저 정의해야 합니다. 그 후, ADT를 어떤 데이터구조를 이용하여 구현할지를 결정해야 합니다. 데이터구조를 고를 때는 만들어진 알고리즘이 ADT의 어떤 operation을 많이 사용하는지, 그리고 어떤 데이터구조가 많이 쓰이는 operation을 효율적으로 구현하는지를 고려하여 결정을 내리게 됩니다. 여기서는 Dijkstra's algorithm을 예시로 위 과정을 따라가보고자 합니다. 

% https://people.maths.bris.ac.uk/~csxam/teaching/dsa/dijkstra.pdf

Dijkstra의 알고리즘은 그래프 위에서 최단경로를 찾기 위해서 만들어진 알고리즘입니다. 이 알고리즘은 priority queue라는 ADT를 사용하는데, 이 priority queue의 구현 방법에 따라서 operation의 복잡도가 달라집니다. 본 단락에서 언급되는 ADT나 데이터구조의 구현에 대해서는 추후 단원에서 다룰 것입니다. 

\paragraph{Priority Queue} Priority queue는 큐 중에서 특수한 형태의 큐로, element들이 우선순위와 같이 큐 속에 저장되어 있습니다. Dequeue시에는 가장 낮은\footnote{가장 높아도 상관없으며, priority를 기반으로 dequeue되는 원소가 정해지는 것이 중요합니다.}  priority를 가진 원소가 큐에서 제거됩니다. Priority queue는 다음의 4개의 operation으로 구성되어 있습니다. 

\begin{itemize} 
\item \_\_init\_\_ : 빈 priority queue를 만듭니다. 
\item push : 한 원소와 priority를 queue에 추가합니다. 
\item decrease\_key : 한 원소의 priority를 낮춥니다. 
\item pop : 가장 priority가 낮은 원소를 큐에서 제거하고, 그 원소를 반환합니다. 
\end{itemize}

\paragraph{Implementation of Priority Queue} 

일반적으로 priority queue를 구현하는 방법은 크게 3가지가 있습니다. Linked list, binaray heap, fibonacci heap입니다. 각 데이터구조당 operation의 시간복잡도는 아래와 같습니다. 

\begin{table}[h]
\begin{tabular}{|l|l|l|l|}
\hline
               & push   & decrease\_key & pop \\ \hline
linked list    & O(1)     & O(n)          & O(n)         \\ \hline
Binary Heap    & O(log n) & O(log n)      & O(log n)     \\ \hline
Fibonacci Heap & O(1)     & O(1)          & O(log n)     \\ \hline
\end{tabular}
\end{table}

\paragraph{Dijkstra's Algorithm} 

Dijkstra의 알고리즘에서는 각각 V\footnote{그래프에서 vertex의 갯수}번의 push, pop, 그리고 E\footnote{그래프에서 edge의 갯수}번의 decrease\_key가 수행됩니다. 따라서, 복잡도는 다음과 같습니다. 

\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
               & Complexity              \\ \hline
Linked List    & O($V^2$) \\ \hline
Binary Heap    & O((E+V) log V)          \\ \hline
Fibonacci Heap & O(E + V log V)          \\ \hline
\end{tabular}
\end{table}

즉, 같은 알고리즘과 같은 ADT더라도 어떠한 데이터구조를 이용하는지에 따라 복잡도가 달라집니다. 따라서 적절한 데이터구조를 선택해야 할 것입니다. 예컨대, push가 많고 상대적으로 pop이 매우 적은 경우에는 binary heap보다 linked list가 더 효과적일 수도 있습니다. 


% \section{Algorithmic Paradigms} 

% \paragraph{Divide and Conquer} 

% \paragraph{Recursion} 

% \paragraph{Dynamic Programming}


\chapter{List of ADTs} 

본 단원에서는 다양한 ADT의 개념과 정의를 살펴보고 이를 이용한 문제를 제시하고, 그 문제를 푸는 알고리즘을 알아볼 것입니다. 본 수업에서는 이 ADT를 다양한 데이터구조를 이용하여 구현하고 이를 이용하여 제시된 문제를 푸는 알고리즘을 구현해볼 것입니다. 

\section{List} 

리스트는 head, tail의 순서쌍이며, head는 저장하는 데이터, tail은 리스트입니다. 이 때 tail이 빈 리스트인 경우는 None이라고 표기합니다. 리스트 구조 자체가 재귀적이기 때문에, 리스트에서 시행할 operation들 중에는 이를 적극적으로 활용하는 경우가 많습니다. 예를 들어서, 리스트에서 가장 큰 element를 찾는 함수를 짠다면, 다음과 같이 생각할 수 있습니다. 

\lstinputlisting[style=python,  
                linerange = {4-10},     
                caption={find\_max  (ListAlgorithms.py)}]{"./examples/list/ListAlgorithms.py"} 
                
즉, 리스트의 모든 원소에 대해서 어떤 함수를 시행하고 싶으면, head에서 그 함수를 시행한 후 재귀적으로 tail에서 그 함수를 시행하면 됩니다. 이러한 재귀 구조의 장점은 트리에서도 유감없이 사용할 수 있습니다. 

\subsection{ADT List Specification} 

위에서는 예시로 필요최소한의 list operation만을 살펴보았지만, 여기서는 조금 더 다양한 operation들을 구현하도록 하겠습니다. 

\begin{itemize} 
\item \_\_init\_\_ : List Constructor
\item \_\_iter\_\_ : 리스트의 원소를 한번씩 traverse하는 iterator\footnote{Iterator는 단순 루프와는 다소 차이가 있습니다. 파이썬에서는 yield를 사용해야 하며, 위에서 간단하게 다룬 바 있습니디.}
\item is\_empty : 리스트가 비어 있으면 True, 아니면 False를 리턴
\item prepend / append : 리스트의 앞/뒤에 어떤 element를 넣는 함수. 기존 리스트를 변화시킴. 
\item add : 리스트의 주어진 위치에 element를 추가하는 함수. 기존 리스트를 변화시킴. 
\item remove : 리스트의 원소 중 하나를 삭제. 기존 리스트를 변화시킴. 
\item change : 리스트의 원소 중 하나를 바꿈. 기존 리스트를 변화시킴. 
\item head : 리스트의 첫 번째 원소를 리턴. 
\item tail : 리스트의 첫 번째 원소를 제외한 나머지 원소들을 리턴. 
\item sort : 리스트를 주어진 기준에 따라 소팅하여 새 리스트를 반환. 기존 리스트는 변하지 않음. 
\item max/min : 리스트의 원소 중 주어진 기준으로 볼 때 가장 큰/작은 원소 반환. 기존 리스트는 변하지 않음. 
\end{itemize}

\section{Queue} 


큐는 일반적으로 선입선출(First In, First Out; FIFO)를 만족하는 데이터구조를 말합니다. 소위 말하는 큐 사인에서 쓰는 큐가 이것이며, 선착순으로 어떤 일을 처리해야 할 때 많이 사용됩니다. 가장 기본적인 데이터구조로 다른 데이터구조를 만들 때에도 많이 쓰입니다. 

큐의 일반적인 변형으로 priority queue가 있습니다. 일반적인 큐는 들어오는 순서가 우선순위이지만, 우선순위 큐는 원소가 들어올 때 priority를 같이 가지고 들어옵니다. 또, pop 시에는 지금 큐에 있는 원소들 중에 가장 priority가 큰 원소가 먼저 pop됩니다. 우선순위 큐는 가깝게는 dijkstra의 알고리즘을 구현하는 것에서부터 멀리는 게임에서 적절한 mmr을 가지는 사람들끼리 큐를 잡아 줄 때나, os에서 프로세스에게 cpu를 분배할 때 등 다양한 곳에서 사용될 수 있습니다. 

\subsection{ADT Queue Specification}

\begin{itemize} 
\item \_\_init\_\_ : Queue Constructor
\item \_\_iter\_\_ : 큐 안의 원소를 한번씩 traverse하는 iterator
\item is\_empty : 큐가 비어 있으면 True, 아니면 False를 리턴
\item push : 큐의 맨 뒤에 원소 삽입. 
\item pop : 큐 맨 앞의 원소 반환하고 삭제. 기존 큐를 바꿈. 
\end{itemize}

\subsection{ADT Priority Queue Specification}


\begin{itemize} 
\item \_\_init\_\_ : Priority Queue Constructor
\item \_\_iter\_\_ : 큐 안의 원소를 한번씩 traverse하는 iterator
\item is\_empty : 큐가 비어 있으면 True, 아니면 False를 리턴
\item push : 큐의 맨 뒤에 원소 삽입. 
\item pop : 큐 맨 앞의 원소 반환하고 삭제. 기존 큐를 바꿈. 
\item decrease\_key : 특정 원소의 priority를 줄임. 기존 큐를 바꿈. 
\end{itemize}

\subsection{Problem Solving Using Queue} 

\paragraph{MMR matching} 

\section{Tree} 


트리는 리스트와 매우 비슷합니다. 트리와 리스트가 다른 것은 보통 트리에서는 head를 루트라고 부른다는 것과, tail이 여러 개 있다는 점입니다. 트리는 일반적으로 대부분의 분류 구조를 나타낼 때 폭넓게 쓰일 수 있으며, DB 등의 데이터 저장이나 분류 등에서도 많이 사용됩니다. 

\subsection{ADT Specification of Tree} 


\begin{itemize} 
\item \_\_init\_\_ : Tree Constructor 
\item iter : 트리 안의 모든 element를 traverse하는 iterator. 위 리스트나 큐에서의 \_\_iter\_\_과는 다르게, 추가 argument인 option에 따라서 iterate하는 순서를 바꿀 수 있다. 
\item \_\_iter\_\_ : 편의를 위한 default iterator 
\item root : 트리의 루트 노드를 반환. 
\item children : 트리의 child들을 담고 있는 리스트. child들 각각 역시 트리이다. 
\item leaves : 트리의 노드들 중 children이 빈 리스트인 노드들을 traverse하는 iteator. 
\item find\_subtree : 트리 중 주어진 element를 루트로 가지는 subtree들의 리스트를 출력. 
\end{itemize}

%\subsection*{Forest} 
%
%\subsection{Problem Solving Using Tree} 
%
%\paragraph{Decision Tree} 
%\paragraph{HTML Parser} 


\section{Graph} 

그래프는 노드들이 임의의 형태로 연결된 것을 말합니다. 이 때 연결 방식에 따라서 그래프의 종류가 나뉩니다. 

\begin{itemize} 
\item directed / undirected
\item weighted
\item cyclic / acylic
\end{itemize}

\subsection{ADT Specification of Graph} 

\begin{itemize} 
\item \_\_init\_\_ : Graph Constructor
\item \_\_iter\_\_ : Graph iterator. 
\item iter : 그래프에 있는 모든 node를 traverse하는 iterator. option에 따라서 traverse하는 순서가 달라짐. 
\item is\_adjacent : 주어진 두 노드가 인접하면 True, 아니면 False를 반환. 
\item adjacent : 주어진 노드와 인접한 모든 노드를 담고 있는 리스트를 반환. 
\item add\_vertex, remove\_vertex : 주어진 노드를 그래프의 vertex에 추가. 
\item add\_edge, remove\_edge : 주어진 노드의 순서쌍을 그래프의 edge에 추가. 
\end{itemize} 
%
%\subsection{Problem Solving Using Graph}
%\paragraph{Computational Graph}



% \chapter{데이터구조 기본} 
% % list 
% % queue
% % stack

% 본 단원에서는 가장 기본적인 ADT인 리스트, 스택, 그리고 큐를 살펴볼 것입니다. 이 중 큐는 우선순위 큐라는 변형 형태도 살펴보도록 하겠습니다. 

% \section*{Data}

% 본 문서에서는 데이터를 다루기 위한 wrapper 클래스로 Node를 사용합니다. 

% \section{List} 

% 리스트는 head, tail의 순서쌍이며, head는 저장하는 데이터, tail은 리스트입니다. 이 때 tail이 빈 리스트인 경우는 None이라고 표기합니다. 리스트 구조 자체가 재귀적이기 때문에, 리스트에서 시행할 operation들 중에는 이를 적극적으로 활용하는 경우가 많습니다. 예를 들어서, 리스트에서 가장 큰 element를 찾는 함수를 짠다면, 다음과 같이 생각할 수 있습니다. 

% \lstinputlisting[style=python,  
                % linerange = {4-10},     
                % caption={find\_max  (ListAlgorithms.py)}]{"./examples/list/ListAlgorithms.py"} 
                
% 즉, 리스트의 모든 원소에 대해서 어떤 함수를 시행하고 싶으면, head에서 그 함수를 시행한 후 재귀적으로 tail에서 그 함수를 시행하면 됩니다. 이러한 재귀 구조의 장점은 트리에서도 유감없이 사용할 수 있습니다. 

% \subsection{ADT List Specification} 

% 위에서는 예시로 필요최소한의 list operation만을 살펴보았지만, 여기서는 조금 더 다양한 operation들을 구현하도록 하겠습니다. 

% \begin{itemize} 
% \item \_\_init\_\_ : 빈 리스트를 만드는 constructor
% \item \_\_iter\_\_ : 리스트의 원소를 한번씩 traverse하는 iterator\footnote{Iterator는 단순 루프와는 다소 차이가 있습니다. 파이썬에서는 yield를 사용해야 하며, 위에서 간단하게 다룬 바 있습니디.}
% \item is\_empty : 리스트가 비어 있으면 True, 아니면 False를 리턴
% \item prepend / append : 리스트의 앞/뒤에 어떤 element를 넣는 함수. 기존 리스트를 변화시킴. 
% \item add : 리스트의 주어진 위치에 element를 추가하는 함수. 기존 리스트를 변화시킴. 
% \item remove : 리스트의 원소 중 하나를 삭제. 기존 리스트를 변화시킴. 
% \item change : 리스트의 원소 중 하나를 바꿈. 기존 리스트를 변화시킴. 
% \item head : 리스트의 첫 번째 원소를 리턴. 
% \item tail : 리스트의 첫 번째 원소를 제외한 나머지 원소들을 리턴. 
% \item sort : 리스트를 주어진 기준에 따라 소팅하여 새 리스트를 반환. 기존 리스트는 변하지 않음. 
% \item max/min : 리스트의 원소 중 주어진 기준으로 볼 때 가장 큰/작은 원소 반환. 기존 리스트는 변하지 않음. 
% \end{itemize}

% \subsection{Implementation of ADT List} 

% \paragraph{Using Linked List} 

% \paragraph{Using Balanced Binary Tree} 

% \section{Queue} 


% 큐는 일반적으로 선입선출(First In, First Out; FIFO)를 만족하는 데이터구조를 말합니다. 소위 말하는 큐 사인에서 쓰는 큐가 이것이며, 선착순으로 어떤 일을 처리해야 할 때 많이 사용됩니다. 가장 기본적인 데이터구조로 다른 데이터구조를 만들 때에도 많이 쓰입니다. 

% 큐의 일반적인 변형으로 priority queue가 있습니다. 일반적인 큐는 들어오는 순서가 우선순위이지만, 우선순위 큐는 원소가 들어올 때 priority를 같이 가지고 들어옵니다. 또, pop 시에는 지금 큐에 있는 원소들 중에 가장 priority가 큰 원소가 먼저 pop됩니다. 우선순위 큐는 가깝게는 dijkstra의 알고리즘을 구현하는 것에서부터 멀리는 게임에서 적절한 mmr을 가지는 사람들끼리 큐를 잡아 줄 때나, os에서 프로세스가 cpu를 점유하게 하는 등 다양한 곳에서 사용될 수 있습니다. 

% \subsection{ADT Queue Specification}

% \begin{itemize} 
% \item \_\_init\_\_ : 빈 큐를 만드는 Constructor
% \item \_\_iter\_\_ : 큐 안의 원소를 한번씩 traverse하는 iterator
% \item is\_empty : 큐가 비어 있으면 True, 아니면 False를 리턴
% \item push : 큐의 맨 뒤에 원소 삽입. 
% \item pop : 큐 맨 앞의 원소 반환하고 삭제. 기존 큐를 바꿈. 
% \end{itemize}

% \subsection{Implementation of ADT Queue}

% \subsubsection{Normal Queue}    
% \paragraph{Using Linked List} 
% \paragraph{Using Balanced Binary Tree} 
% \paragraph{Using Stack} 

% \subsection{ADT Priority Queue Specification}


% \begin{itemize} 
% \item \_\_init\_\_ : 빈 큐를 만드는 Constructor
% \item \_\_iter\_\_ : 큐 안의 원소를 한번씩 traverse하는 iterator
% \item is\_empty : 큐가 비어 있으면 True, 아니면 False를 리턴
% \item push : 큐의 맨 뒤에 원소 삽입. 
% \item pop : 큐 맨 앞의 원소 반환하고 삭제. 기존 큐를 바꿈. 
% \item decrease\_key : 특정 원소의 priority를 줄임. 기존 큐를 바꿈. 
% \end{itemize}

% \subsection{Implementation of Priority Queue} 

% \paragraph{Using Linked List}
% \paragraph{Using Binary Heap} 
% \paragraph{Using Fibonacci Heap} 


% \subsection{Problem Solving Using Queue} 

% \paragraph{MMR Matching} 



% \section{Stack}

% 스택은 큐와 거의 유사하나, 먼저 들어온 원소가 나중에 나오는 선입후출(First In, Last Out; FILO)의 형식을 가집니다. 따라서 스택의 구현 역시 거의 비슷하므로 여기서는 예제만 다루고자 합니다. 

% \subsection{Problem Solving Using Stack}

% % stack 예제 찾을 것 


% \chapter{데이터구조 응용} 
% % tree
% % binary/n-ary
% % balanced binary tree 
% % graph
% % heaps
% \section{Tree} 

% \subsection{ADT Specification of Tree} 

% \begin{itemize} 
% \item \_\_init\_\_ : 빈 트리를 만드는 Constructor 
% \item iter : 트리 안의 모든 element를 traverse하는 iterator. 위 리스트나 큐에서의 \_\_iter\_\_과는 다르게, 추가 argument인 option에 따라서 iterate하는 순서를 바꿀 수 있다. 
% \item \_\_iter\_\_ : 편의를 위한 default iterator 
% \item root : 트리의 루트 노드를 반환. 
% \item children : 트리의 child들을 담고 있는 리스트. child들 각각 역시 트리이다. 
% \item leaves : 트리의 노드들 중 children이 빈 리스트인 노드들을 traverse하는 iteator. 
% \item find\_subtree : 트리 중 주어진 element를 루트로 가지는 subtree들의 리스트를 출력. 
% \end{itemize}

% \subsection{Tree Implementation} 

% \paragraph{Using Linked List} 
% \paragraph{Using Data Structure Tree} 

% \subsection{Problem Solving Using Tree}

% \section{Graph} 

% \subsection{ADT Specification of Graph} 

% \begin{itemize} 
% \item \_\_init\_\_ : Graph Constructor
% \item is\_adjacent : 주어진 두 노드가 인접하면 True, 아니면 False를 반환. 
% \item adjacent : 주어진 노드와 인접한 모든 노드를 담고 있는 리스트를 반환. 
% \item add\_vertex, remove\_vertex : 주어진 노드를 그래프의 vertex에 추가. 
% \item add\_edge, remove\_edge : 주어진 노드의 순서쌍을 그래프의 edge에 추가. 
% \item iter : 그래프에 있는 모든 node를 traverse하는 iterator. option에 따라서 traverse하는 순서가 달라짐. 
% \end{itemize} 

% \subsection{Graph Implementation} 

% \paragraph{Using Adjacency Matrix} 
% \paragraph{Using Adjacency List} 

% \subsection{Algorithms on Graph} 

% \subsubsection{Graph Traversal}
% \paragraph{Breadth First Search} 
% \paragraph{Depth First Search}
% \paragraph{Topological Sort} 

% \subsubsection{Shortest Paths} 
% \paragraph{Dijkstra's Algorithm} 
% \paragraph{Bellamn-Ford Algorithm}
% \paragraph{Floyd-Warshall Algorithm} 
% \paragraph{Johnson's Algorithm} 

% \subsubsection{Minimum Spanning Tree} 

% \paragraph{Prim's Algorithm} 
% \paragraph{Kruskal's Algorithm} 

% \subsection{Problem Solving using Graph}

% % \section{Map} 

% % \subsection{ADT Specification of Map} 
% % \subsection{Map Implementation} 

% % \paragraph{Using Hash Table} 
% % \paragraph{Using Tree} 


% \chapter{데이터구조와 알고리즘의 활용}
% % Problem Solving Competition류 문제 풀이
% % recursion problems 
% % dynamic programming 문제 : list dp, 2d list dp, tree dp 

% \section{Problem Solving Competition 기출문제}

% \subsection{Problem Solving} 

% % 공학적 문제풀이 
% % Sequence Labeling : Conditional Random Field and Viterbi Algorithm (example of dynamic programming)
% % polynomial multiplication (http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/chap32.htm)
% % Fourier Transform for signal analysis 
% \section{Problem Solving on Engineering} 



\end{document}